trigger:
  branches:
    include:
    - main
    - prod

parameters:
  - name: environmentName
    type: string
  - name: serviceConnectionName
    type: string

variables:
- group: ${{ lower(parameters.environmentName) }}-variable-group

stages:
- stage: 'Build'
  displayName: 'Build Projects'
  condition: always()

  variables:
  - name: applicationRole
    value: 'memorypipeline'
  - name: sourceFolder
    value: '$(Build.SourcesDirectory)/memorypipeline'
  - name: dotnetVersion
    value: '6.x'

  jobs:
  - job: 'Build'
    displayName: 'Build $(applicationRole)'

    pool:
      vmImage: 'windows-latest'

    steps:
    #don't clean to cache the node_modules and potentially nuget packages
    - checkout: self
      clean: false 

    #set pipeline variables based on git hash and date
    - script: |
          set mydate=%date:~10,4%%date:~7,2%%date:~4,2%
          for /F "tokens=*" %%g in ('git rev-parse --short HEAD') do (set hash=%%g)
          echo "##vso[task.setvariable variable=ShortCommitHash;]%hash%"
          echo "##vso[task.setvariable variable=OutputPrefix;]%mydate%-%hash%"
          echo "##vso[task.setvariable variable=ArtifactDir;]$(Build.ArtifactStagingDirectory)/%mydate%-%hash%-$(applicationRole)"
          echo "##vso[task.setvariable variable=ArtifactArchive;]$(Build.ArtifactStagingDirectory)/%mydate%-%hash%-$(applicationRole).zip"
      workingDirectory: '$(Build.SourcesDirectory)'

    #install correct .net sdk version
    - task: UseDotNet@2
      displayName: '.NET: Install .NET $(dotnetVersion) SDK'
      inputs:
        packageType: 'sdk'
        version: '$(dotnetVersion)'

    #build project
    
    - task: DotNetCoreCLI@2
      displayName: '.NET: Build $(applicationRole) project'
      inputs:
        command: 'build'
        projects: '$(sourceFolder)/CopilotChatMemoryPipeline.csproj'
        workingDirectory: '$(sourceFolder)'
        arguments: '--configuration Release -r win-x64 --self-contained true --output $(ArtifactDir)"
        publishWebProjects: false
        zipAfterPublish: false

    #we use build rather than publish above to give more flexibility on the output archive name
    #now we build the archive
    - task: ArchiveFiles@2
      inputs:
        rootFolderOrFile: '$(ArtifactDir)'
        includeRootFolder: false
        archiveType: 'zip'
        archiveFile: '$(ArtifactArchive)'
        replaceExistingArchive: true
        verbose: true

    - powershell: Get-ChildItem -Path '$(Build.ArtifactStagingDirectory)/'

    #public memorypipeline artifacts
    - task: PublishBuildArtifacts@1
      displayName: 'Publish: Backend Artifacts'
      inputs:
        pathtoPublish: '$(ArtifactArchive)'
        artifactName: 'drop'


- stage: 'Deploy'
  displayName: 'Deploy Projects'
  condition: succeeded()

  variables:
  - group: ${{ lower(parameters.environmentName) }}-variable-group

  jobs:
  - job: 'Deploy'
    displayName: '2. Deploy MemoryPipeline'

    pool:
      vmImage: 'windows-latest'

    steps:
    - checkout: none

    - task: DownloadPipelineArtifact@2
      inputs:
        buildType: 'current'
        targetPath: '$(Pipeline.Workspace)'

    - task: AzurePowerShell@5
      inputs:
        azureSubscription: ${{parameters.serviceConnectionName}}
        ScriptType: 'InlineScript'
        Inline: |
          $webapp = Get-AzResource -Tag @{"skmemorypipeline"="1"} -ResourceGroupName '$(variables.RESOURCE_GROUP_NAME)'
          Write-Host "##vso[task.setvariable variable=TargetResourceName;]$webapp.Name"
        preferredAzurePowerShellVersion: '3.1.0'

    - task: AzureRmWebAppDeployment@4
      inputs:
        ConnectionType: 'AzureRM'
        appType: 'webApp'
        WebAppName: '$(TargetResourceName)'
        packageForLinux: '$(Pipeline.Workspace)/**/*.zip'
        AppSettings: '-DEPLOY_FROM_PACKAGE 1'